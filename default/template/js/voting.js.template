// == begin voting.js
//
//function PingUrl(url) { // loads arbitrary url
//// by creating an <img src=url on the page
//// it ain't pretty, but it's compatible
//	var img = document.createElement('img');
//	img.setAttribute("src", url);
//	document.body.appendChild(img);
//	// todo get rid of image eventually
//	// server-side shove an image into it as needed
//}


function PingUrl(url) { // loads arbitrary url via image
// compatible with most js

	// #todo
	//	if (window.XMLHttpRequest) {
	//		pingUrlClient = new XMLHttpRequest();
	//		pingUrlClient.open("GET", url, true);
	//
	//		pingUrlClient.onreadystatechange = signVoteCallback;
	//
	//		freshClient.send();
	//	}

	if (document.images) {
		if (document.images.length) {
			// use last image on page, if possible. this should be the special pixel image.
			var img = document.images[document.images.length - 1];

			if (img) {
				img.setAttribute("src", url);
			}
		} else {
			var img = document.images[0];

			if (img) {
				img.setAttribute("src", url);
			}
		}
	}
}


//function OptionsDefault(token, privKeyObj) {
//	this.data = token;
//	this.privateKeys = [privKeyObj];
//}

function signCallback (signed) {
	var url = '/post.html?comment=' + encodeURIComponent(signed.data);

	if (PingUrl(url)) {
		// todo incrememnt counter
		if (window.AmIFresh) {
			// if fresh.js is included, decrease check interval
			intFreshTimeout = 1000;
			AmIFresh();
		}
	}
}

function signVote(t, token) { // signs a vote from referenced vote button
// t = reference to calling button's 'this'
// token = full voting token, in the format vote/fileHash/ballotTime/voteValue/checksum
	if (document.getElementById && window.getPrivateKey) {
	// basic dumb feature check #todo make smarter feature check ;
	// needs better compatibility for older browsers
		// get private key

		if (t.innerHTML) {
			// update count in vote link
			//alert('DEBUG: signVote: t.innerHTML');
			var ih = t.innerHTML;
			if (ih.indexOf('(') == -1) {
				//alert('DEBUG: signVote: ( not found');
				t.innerHTML = ih + '(1)';
			} else {
				//alert('DEBUG: signVote: ( found');

				var numVal = ih.substring(ih.indexOf('(') + 1, ih.indexOf(')'));
				var newVal = parseInt(numVal) + 1;
				var hashTag = ih.substring(0, ih.indexOf('('));
				t.innerHTML = hashTag + '(' + newVal + ')';
			}
			//alert('DEBUG: signVote: finished with t.innerHTML');
		}

		var privkey = getPrivateKey();
		//alert('DEBUG: signVote: privkey: ' + !!privkey);

		if (!privkey) {
			//alert('DEBUG: !privkey');
			// if there is no private key, just do a basic unsigned vote;

			if (PingUrl(t.href)) {
				// todo increment counter
				if (window.AmIFresh) {
					// if fresh.js is included, decrease check interval
					intFreshTimeout = 1000;
					AmIFresh();
				}
			}
		} else {
			// there is a private key
			//alert('DEBUG: privkey is true');

			// load the private key into openpgp
			var privKeyObj = openpgp.key.readArmored(privkey).keys[0];
			var options;
			options = new Object();
			options.data = token;
			options.privateKeys = privKeyObj;
			openpgp.config.show_version = false;
			openpgp.config.show_comment = false;

			// sign the voting token and send to post.html when finished
			openpgp.sign(options).then(signCallback);
		}

		return false; // cancel link click-through
	} else {
		//	    if (document.images) {
		//	        var myUrl = window.location;
		//	    	document.images[0].src = '/post.html?mydomain=' + myUrl;
		//
		//	    	//alert('DEBUG: t = ' + t);
		//
		//	    	return false;
		//	    }
	}

	return true; // allow link click to happen
}

// == end voting.js
// == begin crypto2.js

// these are used to globally store the user's fingerprint and username
var myFingerprint = '';
var myUsername = '';

function MakeKey() {
	//alert('DEBUG: MakeKey() begin');
	var openpgp = window.openpgp;

	var gt = String.fromCharCode(62);

	if (openpgp) {
		// if openpgp is loaded, proceed with client-side key generation

		// defaults for testing #todo
		var bits = 512;
		var username = 'Anonymous';

		openpgp.initWorker({path:'openpgp.worker.js'});

		var options;
		if (bits == 512 || bits == 1024 || bits == 2048 || bits == 4096) {
			options = {
				userIds: [{ name: username }],
				numBits: bits,
				passphrase: ''
			};
		} else {
			options = {
				userIds: [{ name: username }],
				curve: bits,
				passphrase: ''
			};
		}

		openpgp.config.show_version = false;
		openpgp.config.show_comment = false;

		openpgp.generateKey(options).then(
			function(key) {
				var privkey = key.privateKeyArmored; // '-----BEGIN PGP PRIVATE KEY BLOCK ... '
				var pubkey = key.publicKeyArmored;   // '-----BEGIN PGP PUBLIC KEY BLOCK ... '
				var revocationCertificate = key.revocationCertificate; // '-----BEGIN PGP PUBLIC KEY BLOCK ... '

				openpgp.key.readArmored(privkey);

				// read it into pgp object
				var privKeyObj = openpgp.key.readArmored(privkey);;

				// get the public key out of it
				var pubKeyObj = privKeyObj.keys[0].toPublic();

				// store the armored version into localstorage
				var pubkey = pubKeyObj.armor();

				// get the fingerprint as uppercase hex and store it
				var myFingerprint = pubKeyObj.primaryKey.keyid.toHex().toUpperCase();

				// get username out of key
				var myUsername = pubKeyObj.users[0].userId.userid;

				var gt = String.fromCharCode(62);

				var avatar = escapeHTML(myUsername);

				window.localStorage.setItem('privatekey', privkey);
				window.localStorage.setItem('publickey', pubkey);
				window.localStorage.setItem('fingerprint', myFingerprint);
				window.localStorage.setItem('avatar', avatar);

				document.cookie = "test=" + myFingerprint;

				//window.location = '/profile.html?' + myFingerprint;
				window.location = '/write.html#inspubkey';
			}
		);

		return false;
	}

	return true;
}

function getPrivateKey() { // get private key from local storage
// returns null otherwise
    //alert('DEBUG: getPrivateKey() begins');

	if (window.localStorage) {
	    //alert('DEBUG: getPrivateKey: window.localStorage is true, checking for localStorage.getItem(privatekey)');

		var privateKey = localStorage.getItem("privatekey");

		if (privateKey === null || privateKey.length === 0) {
		    //alert('DEBUG: getPrivateKey: found nothing in localStorage');

			return null;
		} else {
		    //alert('DEBUG: getPrivateKey: found something in localStorage: ' . privateKey);

			return privateKey;
		}
	} else {
		return null;
	}
}

function getPublicKey() { // get public key from local storage
// returns null otherwise
    //alert('DEBUG: getPublicKey() begins');

	if (window.localStorage) {
	    //alert('DEBUG: getPublicKey: window.localStorage is true, checking for localStorage.getItem(publickey)');

		var publicKey = localStorage.getItem("publickey");

		if (publicKey === null || publicKey.length === 0) {
		    //alert('DEBUG: getPublicKey: found nothing in localStorage');

			return null;
		} else {
		    //alert('DEBUG: getPublicKey: found something in localStorage: ' . publicKey);

			return publicKey;
		}
	} else {
		return null;
	}
}

function removeStoredKeys2() {
	if (window.localStorage) {
		var ls = window.localStorage;
		ls.removeItem('privatekey');
		ls.removeItem('publickey');
		ls.removeItem('fingerprint');
		ls.removeItem('avatar');
	}
}

function setPrivateKeyFromTxt(newKey) { // set the current private key and refresh the pubkey, fingerprint, and avatar too
	var gt = String.fromCharCode(62);

    //window.localStorage.setItem("privatekey", newKey);

    if (!window.openpgp && document.head && document.head.appendChild && document.getElementById && window.localStorage) {
        var script = document.createElement('script');
        script.src = '/openpgp.js';
        script.async = false; // This is required for synchronous execution
        document.head.appendChild(script);
    }

    var openpgp = window.openpgp;

    openpgp.config.show_version = false;
    openpgp.config.show_comment = false;

    // read it into pgp object
    var privKeyObj = openpgp.key.readArmored(newKey);

    // get the public key out of it
    var pubKeyObj = privKeyObj.keys[0].toPublic();

    // store the armored version into localstorage
    var pubkey = pubKeyObj.armor();
    window.localStorage.setItem("publickey", pubkey);

    // get the fingerprint as uppercase hex and store it
    var myFingerprint = pubKeyObj.primaryKey.keyid.toHex().toUpperCase();

    // get username out of key
    var myUsername = pubKeyObj.users[0].userId.userid;

    var gt = unescape('%3E');

    var avatar = escapeHTML(myUsername);

    var privkey = privKeyObj.privateKeyArmored;

    window.localStorage.setItem('privatekey', newKey);
    window.localStorage.setItem('publickey', pubkey);
    window.localStorage.setItem('fingerprint', myFingerprint);
    window.localStorage.setItem('avatar', avatar);

    document.cookie = "test=" + myFingerprint;

    //window.location = '/profile.html?' + myFingerprint;
    window.location = '/write.html#inspubkey';
}


function signMessage() {
	//alert('DEBUG: signMessage() begin');

	var privkey = getPrivateKey();

	if (privkey) {
		//alert('DEBUG: signMessage: privkey is true');

		var textbox = document.getElementById('comment');
		var composeForm = document.getElementById('compose');

		if (textbox && composeForm) {
			//alert('DEBUG: signMessage: textbox && composeForm is true');

//			textbox.style.color = '#00ff00';
//			textbox.style.backgroundColor = '#c0c000';

			var message = textbox.value;

			// if the message already has the header,
			//    assume it's already signed and return
			// #todo make it also verify that it's signed before returning
			// #todo some kind of *unobtrusive* indicator/confirmation/option
			// #todo change color of textbox when message is properly signed

			if (message.trim().substring(0, 34) == ('-----BEGIN PGP SIGNED MESSAGE-----')) {
				//alert('DEBUG: signMessage: message is already signed, returning');

				return true;
			}

			if (message.trim().substring(0, 36) == ('-----BEGIN PGP PUBLIC KEY BLOCK-----')) {
				//alert('DEBUG: signMessage: message contains public key, returning');

				return true;
			}

			var replyTo = document.getElementById('replyto');

			if (replyTo) {
				var replyToId = replyTo.value;

				if (replyToId) {
					if (-1 < message.indexOf('>>' + replyToId)) {
					} else {
						message = '>>' + replyToId + '\n\n' + message;
					}
				}
			}
//
			var privKeyObj = openpgp.key.readArmored(privkey).keys[0];
//
//			privateKey.decrypt('hello');
//
//			var privKeyObj = (await openpgp.key.readArmored(privkey)).keys[0];
//			await privKeyObj.decrypt(passphrase);
//

			options = {
				data: message,                             // input as String (or Uint8Array)
				privateKeys: [privKeyObj]                  // for signing
			};

			openpgp.config.show_version = false;

			openpgp.config.show_comment = false;

			openpgp.sign(options).then(function(signed) {
				textbox.value = signed.data;
				composeForm.submit();
			});

			return false;
		}

		return true;
	} else {
		// this is an edge case
		// user signed out in another window, but wants to sign in this one
		// signing is no longer possible, so just submit to be on safe side
	}

	return true;
}


function cryptoJs() {
	return 1;
}


// == end crypto2.js
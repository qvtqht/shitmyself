
// these are used to globally store the user's fingerprint and username
var myFingerprint = '';
var myUsername = '';

// performs logout by removing stored private key
function logOut(t) {
	if (t) {
		disarmSignoutButton(t);
	}
	logOut2();
}

function buttonSignOut(t) {
	if (window.iii) {
		logOut(t);
	} else {
		window.privKeyTrash = getPrivateKey();

		removeStoredKeys();

		document.getElementById('locm').style.display='inline';
		t.style.backgroundColor='red';
		t.style.color='white';window.iii=1

		window.confct = 11;
		document.getElementById('btnUndo').value = 'Undo? ' + window.confct;

//		setTimeout(function(){
//			disarmSignoutButton(t);
//		}, 10000);

		var signinBox = document.getElementById('signin');
		signinBox.innerHTML = '<a href="/profile.html">Profile</a>';

		setTimeout(function(){
			signoutCounterDecrement();
		}, 1000);
	}
}

function undoSignout() {
	setPrivateKey(window.privKeyTrash);
	saveId();

	t = document.getElementById('rmid');
	disarmSignoutButton(t);

	var signinBox = document.getElementById('signin');
	signinBox.innerHTML = '<a href="/profile.html"><i>Profile</i></a>';

//	var logo = document.getElementById('logo');
//	if (logo) {
//		logo.href = '/author/' + fingerprint
//	} #todo

}

function signoutCounterDecrement() {
	var ct = window.confct;

	if (!window.privKeyTrash) {
		return;
	}

	if (ct) {
		if (isNaN(ct)) {
			// nothing
		} else {
			if (ct > 0) {
				window.confct = (ct - 1);
				bu = document.getElementById('btnUndo');
				bu.value = "Undo? " + ct;

				setTimeout(function(){
					signoutCounterDecrement();
				}, 1000);
			}
		}
	} else if (ct == 0) {
		var rmid = document.getElementById('rmid');
		buttonSignOut(rmid);
		logOut2();
		disarmSignoutButton(rmid);
		window.privKeyTrash = '';
		showHideForms();
	}
}

function disarmSignoutButton(t) {
	t.style.backgroundColor = '#c0c0c0';
	t.style.color = 'red';
	window.iii = 0;
	window.privKeyTrash = '';
	document.getElementById('locm').style.display='none';
}

function makePaste() {
	alert();
}

var loading = document.getElementById('loading');
if (loading) {
	loading.style.display = 'none';
}


// retrieve stored user fingerprint from localstorage
function getUserFp() {
	var fingerprint = localStorage.getItem("fingerprint");
	if (fingerprint === null || fingerprint.length === 0) {
		return null;
	} else {
		return fingerprint;
	}
}

// retrieve previously built avatar from localstore
// this is already in html form
function getAvatar() {
	var myAvatar = localStorage.getItem("avatar");
	if (myAvatar === null || myAvatar.length === 0) {
		return null;
	} else {
		return myAvatar;
	}
}

function valReplyToken() {
// before we sign the message, we need to ensure that
// there is a reply token if it is a reply form

	sp = document.getElementById('replySignedContainer');
}

// if there's a user fingerprint,
// this checks for a place to put a "post as" or "reply as" button
// and if it exists, puts the button there
if (getUserFp()) {
	var sp = document.getElementById('signAndPost');
	var actName = 'Post as ';
	if (!sp) {
		sp = document.getElementById('replySignedContainer');
		actName = 'Reply as ';
	}
	if (sp) {
		sp.innerHTML = '<button onclick="signMessage();">' + actName + getAvatar() + '</button>';
	}
}

// this is for the identity page
// it shows and hides the register and logged in forms
// depending on the currently logged in status
// logged in =  create id is hidden, current id is displayed
// logged out = create id is shown, current id is hidden
// this will also enable/disable the restore/copy buttons in the private key form
function showHideForms() {
    // if user fingerprint exists
	if (getUserFp()) {
	    //current id form, show it
		var formCur = document.getElementById('formCurId');
		if (formCur) {
			formCur.style.display = 'block';
		}

        //create id form, hide it
		var formCreate = document.getElementById('formCreateId');
		if (formCreate) {
			formCreate.style.display = 'none';
		}

		var formAdmin = document.getElementById('formAdminId');
		if (formAdmin) {
			if (getUserFp() == '$currentAdminId') {
				formAdmin.style.display = 'block';
			}
		}

		var signinBox = document.getElementById('signin');

		signinBox.innerHTML = '<a href="/profile.html"><i>Profile</i></a>';
	} else {
	// else means user is not logged in

	    // current id form, hide it
		var formCur = document.getElementById('formCurId');
		if (formCur) {
			formCur.style.display = 'none';
		}

        // create form, show it
		var formCreate = document.getElementById('formCreateId');
		if (formCreate) {
			formCreate.style.display = 'block';
		}

		var formAdmin = document.getElementById('formAdminId');
		if (formAdmin) {
			formAdmin.style.display = 'none';
		}

		var signinBox = document.getElementById('signin');

		signinBox.innerHTML = '<a href="/profile.html">Profile</a>';
	}

    // hide the loading screen if it can be found
	var loading = document.getElementById('loading');
	if (loading) {
		loading.style.display = 'none';
	}
}

// call showHideForms()
showHideForms();

function logOut2() {
	removeStoredKeys();

    // clear the private key textbox if it can be found
	var textbox = document.getElementById("privatekey");
	if (textbox) {
		textbox.value = '';
	}

    // clear the public key textbox if it can be found
	textbox = document.getElementById("publickey");
	if (textbox) {
		textbox.value = '';
	}

    // remove displayed avatar at the top of the page
	var avatar = document.getElementById("myid");
	if (avatar) {
		avatar.innerHTML = '';
	}

    // remove the displayed avatar on the page
	avatar = document.getElementById("myAvatar");
	if (avatar) {
		avatar.innerHTML = '';
	}

    // show and hide the correct forms on the page, if applicable
	showHideForms();
}

// remove login-related stored keys
function removeStoredKeys() {
    // remove the keys
	window.localStorage.removeItem("privatekey");
	window.localStorage.removeItem("publickey");
	window.localStorage.removeItem("fingerprint");
	window.localStorage.removeItem("avatar");
}

// this is a hack i found on stacko for escaping html
var escapeTA = document.createElement('textarea');
function escapeHTML(html) {
	escapeTA.textContent = html;
	return escapeTA.innerHTML;
}
function unescapeHTML(html) {
	escapeTA.innerHTML = html;
	return escapeTA.textContent;
}

// copy to clipboard i found, doesn't work on iphone
function fallbackCopyTextToClipboard(textareaId) {
  var textArea = document.getElementById(textareaId);
  textArea.focus();
  textArea.select();

  try {
	var successful = document.execCommand('copy');
	var msg = successful ? 'successful' : 'unsuccessful';
	console.log('Fallback: Copying text command was ' + msg);
  } catch (err) {
	console.error('Fallback: Oops, unable to copy', err);
  }
}

// copy to clipboard i found, doesn't work on iphone
function copyTextToClipboard(textareaId) {
  var textbox = document.getElementById(textareaId);
  var text = textbox.value;

  if (!navigator.clipboard) {
	fallbackCopyTextToClipboard(textareaId);
	return;
  }
  navigator.clipboard.writeText(text).then(function() {
	console.log('Async: Copying to clipboard was successful!');
  }, function(err) {
	console.error('Async: Could not copy text: ', err);
  });
}


// gets the private key from local storage
// returns null otherwise
function getPrivateKey() {

	var privateKey = localStorage.getItem("privatekey");

	if (privateKey === null || privateKey.length === 0) {
		return null;
	} else {
		return privateKey;
	}
}


// called from write.html#inspubkey
// used for sharing the stored public key automatically
function insertPubKey() {
	var comment = document.getElementById("comment");
	if (comment) {
		var pubkey = getPublicKey();

		if (pubkey) {
			comment.value = pubkey;
		}
	}
}

// gets current user's cached public key from localstorage
function getPublicKey() {
	var publicKey = localStorage.getItem("publickey");
	if (publicKey === null || publicKey.length === 0) {
		return null;
	} else {
		return publicKey;
	}
}

// onload function for identity page
function identityOnload() {
	var pk = getPrivateKey();

    // is there a private key?
	if (pk) {
	    // if there's a private key, see if the user wants to log out
	    // by looking for #logout or #signout in the url
	// disabled due to us not wanting this link to work
		if (0 && window.location.hash &&	(window.location.hash == '#logout' || window.location.hash == '#signout')) {
		    // log out
   			logOut();
   			// refresh the pk variable (should be null now)
   			pk = getPrivateKey();

            // refresh the page to update the menubar
            // #todo make this happen without refreshing the page
   			location.reload();
   	    } else {
   	        // otherwise just make sure the private key textbox is populated
			var textbox = document.getElementById("privatekey");

            // if it exists
			if (textbox) {
				textbox.value = pk;
			}
		}
	}

    // if there's a public key, and a public key textbox, populate it
	var pubk = getPublicKey();
	if (pubk) {
		var textboxPub = document.getElementById("publickey");

		if (textboxPub) {
			textboxPub.value = pubk;
		}
	}

    // if there's a pk, do a saveId(); just for the heck of it? dunno
	if (pk) {
		saveId();
	}

    // if there's a textbox for a name, populate it with the default
    // the default is set in config/prefill_user_name
    // and then templated in where $prefillUsername is
    var nametext = document.getElementById("name");
	if (nametext) {
		if (nametext.value == '') {
			nametext.value = "$prefillUsername";
		}
	}

    // show and hide identity page forms as necessary
	showHideForms();

    // here we do the same thing we did above, checking for #logout and #signout? #strange #todo
	// disabled
	if (0 && window.location.hash) {
		if (window.location.hash == '#logout' || window.location.hash == '#signout') {
			if (getPrivateKey()) {
				logOut();
			}
		}
	}
}

// puts generated html avatar into localstorage
function setAvatar(avatar) {
	window.localStorage.setItem("avatar", avatar);
}

// converts hex characters to symbols for the now unused
// avatars that included different symbols instead of just
// two asterisks
function hexToChar(string) {
	return string.replace(/0/gi,'~').replace(/1/gi,'@').replace(/2/gi,'#').replace(/3/gi,'$').replace(/4/gi,'%').replace(/5/gi,'^').replace(/6/gi,'&').replace(/7/gi,'*').replace(/8/gi,'+').replace(/9/gi,'=').replace(/a/gi,'>').replace(/b/gi,'<').replace(/c/gi,'|').replace(/d/gi,'}').replace(/e/gi,':').replace(/f/gi,'+');
}

// if there's a private key textbox,
// set the current private key and refresh the pubkey, fingerprint, and avatar too
// not much validation currently #todo
function saveId() {
    // look for textbox
	var textbox = document.getElementById("privatekey");

	if (textbox) {
		var privkey = textbox.value;

        // store it to localstorage
		setPrivateKey(privkey);

		var openpgp = window.openpgp;

		openpgp.config.show_version = false;
		openpgp.config.show_comment = false;

        // read it into pgp object
		var privKeyObj = openpgp.key.readArmored(privkey);;

        // get the public key out of it
		var pubKeyObj = privKeyObj.keys[0].toPublic();

        // store the armored version into localstorage
		var pubkey = pubKeyObj.armor();
		setPublicKey(pubkey);

        // get the fingerprint as uppercase hex and store it
		myFingerprint = pubKeyObj.primaryKey.keyid.toHex().toUpperCase();
		window.localStorage.setItem("fingerprint", myFingerprint);

        // get username out of key
		myUsername = pubKeyObj.users[0].userId.userid;

		var color1 = myFingerprint.substr(0, 6);
		var color2 = myFingerprint.substr(3, 6);
		var color3 = myFingerprint.substr(6, 6);
		var color4 = myFingerprint.substr(9, 6);

		var avatar = '';

//		var char1 = myFingerprint.substr(12, 1);
//		var char2 = myFingerprint.substr(13, 1);
//		var char3 = myFingerprint.substr(14, 1);

		//char1 = hexToChar(char1);
		//char2 = hexToChar(char2);
		//char3 = hexToChar(char3);
		//char4 = hexToChar(char4);

		var char1 = '*';
		var char2 = '*';

		avatar = ''

			+ '<span class=avatar style="background-color: #' + color1 + '">'
			+ '<span class=icon>'
			+ '<font color="#' + color2 + '">' + char1 + '</font>'
			+ '<font color="#' + color3 + '">' + char2 + '</font>'
			//+ '<font color="#' + color4 + '">' + char3 + '</font>'
			+ '</span>'
			+ '<span class=username>' + escapeHTML(myUsername) + '</span>'
			+ '</span>';

		setAvatar(avatar);

        // if there is a myid box, populate it appropriately
		var myidBox = document.getElementById('myid');
		if (myidBox) {
			var myAvatar = localStorage.getItem('avatar');
			var signinBox = document.getElementById('signin');

			if (myAvatar == null || myAvatar.length == 0) {
				if ( !document.getElementById("privatekey")) {
					signinBox.innerHTML = '<a href="/profile.html">Login</a>';
				}
			} else {
				//signinBox.innerHTML = '';

				var myFp = localStorage.getItem('fingerprint');

				//myidBox.innerHTML = '<a href="/profile.html" class=avatar>' + myAvatar + '</a>';
				signinBox.innerHTML = '<a href="/profile.html"><i>Profile</i></a>';

				var myId2 = document.getElementById('myId2');
				if (myId2) {
//					myId2.innerHTML = getAvatar();
					myId2.innerHTML = '<a href="/author/' + myFp + '/">' + getAvatar() + '</a>'; //todo remove hardcoding of url
				}

				var myIdProfile = document.getElementById('myIdProfile');
				if (myIdProfile) {
					var profileUrl = '/author/' + myFingerprint + '/';

					if (UrlExists(profileUrl)) {
						myIdProfile.innerHTML = '<span class=beginner><a href="' + profileUrl + '">Go to your Profile page</a></span>';
						ShowAdvanced(1);
					} else {
						myIdProfile.innerHTML = '';
					}
				}

				var myCrea = document.getElementById('myCrea');
				if (myCrea) {
					myCrea.innerHTML = pubKeyObj.primaryKey.created.toString();
				}

				var myFinger = document.getElementById('myFP');
				if (myFinger) {
					myFinger.innerHTML = pubKeyObj.primaryKey.keyid.toHex().toUpperCase();
				}
			}

			showHideForms();
	    }
    }
}

function setPrivateKey(privateKey) {
	window.localStorage.setItem("privatekey", privateKey);
}

function setPublicKey(publicKey) {
	window.localStorage.setItem("publickey", publicKey);
}

function getPublicKeyFromPrivateKey(privateKey) {
	var openpgp = window.openpgp;
	openpgp.initWorker({path:'openpgp.worker.js'});

	var privKeyObj = openpgp.key.readArmored(privateKey).keys[0];
}

function makePrivateKey(username, bits) {
	if (typeof(Storage) !== "undefined") {
		var privateKey = getPrivateKey();

		if (privateKey === null || privateKey.length === 0) {
			var privkey;
			var pubkey;

			var openpgp = window.openpgp;
			openpgp.initWorker({path:'openpgp.worker.js'});

			var options;
			if (bits == 512 || bits == 1024 || bits == 2048 || bits == 4096) {
				options = {
					userIds: [{ name: username }],
					numBits: bits,
					passphrase: ''
				};
			} else {
				options = {
					userIds: [{ name: username }],
					curve: bits,
					passphrase: ''
				};
			}

			var textbox = document.getElementById("privatekey");
			var genStatus = document.getElementById('genStatus');
			if (genStatus) {
				genStatus.innerHTML = 'Working...';
			}
			var cSb = document.getElementById('cSb');
			if (cSb) {
				cSb.disabled = 1;
			}

			openpgp.config.show_version = false;
			openpgp.config.show_comment = false;

			openpgp.generateKey(options).then(
				function(key) {
					setPrivateKey(key.privateKeyArmored);
					if (textbox) {
						textbox.value = key.privateKeyArmored;
					}
					if (genStatus) {
						genStatus.innerHTML = '';
					}
					if (cSb) {
						cSb.disabled = 0;
					}

					setPublicKey(key.publicKeyArmored);

					saveId();

					sharePubKey();

					var btnSharePubkey = document.getElementById('btnSharePub');
					if (btnSharePubkey) {
						btnSharePubkey.value = 'Share Public Key';
						btnSharePubkey.disabled = false;
					}

					//return frames["frame"].location.host;

					//window.open('/write.html#inspubkey', '_self');
				}
			);
		} else {
			// key already exists in storage
		}
	} else {
		// sorry, your browser does not support Web Storage...
	}
}

function sharePubKey() {
	var iframe = document.createElement("iframe");
	iframe.src = '/write.html#inspubkey';
	iframe.name = "inspubkey"
	iframe.style.display = 'none';
	document.body.appendChild(iframe);


//	window.open('/write.html#inspubkey', '_self');
}

function makeKeyFromInputs() {
	var privkey = getPrivateKey();

	if (privkey) {
		logOut2();
	}

	var user = document.getElementById('name').value;
	var bits = document.getElementById('bits').value;

	makePrivateKey(user, bits);
}

function insPubKey() {
	var pubkey = getPublicKey();

	if (pubkey) {
		var textbox = document.getElementById('comment');

		if (textbox) {
			if (pubkey) {
				textbox.value = pubkey;

				var writeIntro = document.getElementById('writeintro');
				if (writeIntro) {
					writeIntro.innerHTML = '<p class=writeinfo>Your public key is now being shared with the server. Please wait a moment...</p>';
				}

				var composeForm = document.getElementById('compose');
				if (composeForm) {
					composeForm.submit();
				}
			}
		}
	}
}

function insProfileTemplate() {
	var pubkey = getPublicKey();

	if (pubkey) {
		var textbox = document.getElementById('comment');

		if (textbox) {
			if (pubkey) {
				var writeIntro = document.getElementById('writeintro');
				if (writeIntro) {
					writeIntro.innerHTML = '<p class=writeinfo>This post will replace your current profile, if there is one set for you, as long as you take care to retain the header and footer.</p>';
				}

				textbox.value = '-----BEGIN PROFILE-----\n\n[This is just a template. All information is optional to provide. Edit and format as you like.]\n\nName: \n\nSelf-summary:\n\nFavorite Books:\n\nFavorite Quotes:\n\nContact Information:\n\n-----END PROFILE-----' ;
			}
		}
	}
}



function insVotes() {
	var vv = localStorage.getItem('vvvv');

	if (vv) {
		var textbox = document.getElementById('comment');

		if (textbox) {
			textbox.value = vv;
			localStorage.removeItem('vvvv');

			var writeIntro = document.getElementById('writeintro');
			if (writeIntro) {
				writeIntro.innerHTML = '<p class=writeinfo><b>Important: Press the Post button to register your votes.</b> You can also comment on a separate line from the command(s). Thank you for taking the time!</p>';
			}
		}
	}
}

function UrlExists(url) {
    var http = new XMLHttpRequest();
    http.open('HEAD', url, false);
    http.send();
    return (http.status==200);
}

function writeOnload2() {
	if (window.location.hash) {
		if (window.location.hash == '#inspubkey') {
			insPubKey();
		}
		if (window.location.hash == '#insvotes') {
			insVotes();
		}
		if (window.location.hash == '#profile') {
			insProfileTemplate();
		}
	}
	if (window.localStorage && window.localStorage.getItem('writesmall')) {
	    var writebox = document.getElementById('comment');
	    if (writebox) {
	        writebox.value = localStorage.getItem('writesmall');
	        localStorage.removeItem('writesmall');
	    }
	}
	if (document.getElementById) {
		var writeAdvL = document.getElementById('writeAdvL');
		if (writeAdvL) {
			writeAdvL.style.display = 'inline';
		}
		var userRadio = document.getElementById('userRadio');
//		alert(userRadio);
		if (userRadio) {
			if (window.getAvatar) {
				if (getAvatar()) {
					userRadio.innerHTML = '<label for=asign><input id=asign type=radio name=a value=sign> Sign as ' + getAvatar() + '</label>';
					//}
					var asign = document.getElementById('asign');
					if (asign) {
						asign.checked = 1;
						asign.checked = true;
					}
					//userRadio.innerHTML = '...';
				} else {
					userRadio.innerHTML = 'Sign in to post under identity.';
				}
			}
		}
	}
}

function writeSubmit() {
	if (document.forms['compose'].aanon.checked) {
		return true;
	} else if (document.forms['compose'].asign.checked) {
		signMessage();
		return false;
	} else {
		console.log('neither anonymous nor signed option is checked. this should not happen under normal circumstances. submitting anyway!');
		return true;
		// this should not happen
	}
}

function signForm(formId) {
	var form = document.getElementById(formId);
	if (form) {
		var elements = form.elements;

		for (var i=0, element; element = elements[i++];) {
			//alert(element.type);
			//alert(element.name);
			//alert(element.value);
		}

		//	var elements = document.getElementById("my-form").elements;
		//
		//    for (var i = 0, element; element = elements[i++];) {
		//        if (element.type === "text" && element.value === "")
		//            console.log("it's an empty textfield")
		//    }

		//function getFormElelemets(formName){
		//  var elements = document.forms[formName].elements;
		//  for (i=0; i<elements.length; i++){
		//    some code...
		//  }
		//}

		//document.getElementById("someFormId").elements;


		//document.forms["form_name"].getElementsByTagName("input");


	} else {
		return null;
	}
}

//signForm('compose');
//
//function signMessage2(message) {
//	var privkey = getPrivateKey();
//
//	if (privkey) {
//		var textbox = document.getElementById('comment');
//		var composeForm = document.getElementById('compose');
//
//		textbox.style.color = '#00ff00';
//		textbox.style.backgroundColor = '#c0c000';
//
//		if (textbox && composeForm) {
//			var message = textbox.value;
//
//			var privKeyObj = openpgp.key.readArmored(privkey).keys[0];
//
//			options = {
//				data: message,                             // input as String (or Uint8Array)
//				privateKeys: [privKeyObj]                  // for signing
//			};
//
//			openpgp.config.show_version = false;
//
//			openpgp.config.show_comment = false;
//
//			openpgp.sign(options).then(function(signed) {
//				textbox.value = signed.data;
//				composeForm.submit();
//			});
//		}
//	} else {
//		alert('No identity defined, cannot sign.');
//	}
//
//}

function signVote(t, token) {
	var privkey = getPrivateKey();

	if (!privkey) {
		if (UrlExists(t.href)) {
			t.enabled = false;
			t.style.backgroundColor = '#408040'; //#todo
			t.style.borderRadius = '5pt'; //#todo
		}
	} else {
		t.style.backgroundColor = '#c0c0c0';
		t.enabled = false;

		var privKeyObj = openpgp.key.readArmored(privkey).keys[0];

		options = {
			data: token,                             // input as String (or Uint8Array)
			privateKeys: [privKeyObj]                  // for signing
		};

		openpgp.config.show_version = false;

		openpgp.config.show_comment = false;

		openpgp.sign(options).then(function(signed) {
			var url = '/gracias.html?comment=' + encodeURIComponent(signed.data);

			if (UrlExists(url)) {
				t.enabled = false;
				t.style.backgroundColor = '#8080c0'; //#todo
				t.style.color = '#f0f0f0';
				t.style.borderRadius = '5pt'; //#todo
			}
		});
	}

	return false;
}

function signMessage() {
	var privkey = getPrivateKey();

	if (privkey) {
		var textbox = document.getElementById('comment');
		var composeForm = document.getElementById('compose');

		if (textbox && composeForm) {
//			textbox.style.color = '#00ff00';
//			textbox.style.backgroundColor = '#c0c000';

			var message = textbox.value;

			// if the message already has the header,
			//    assume it's already signed and return
			// #todo make it also verify that it's signed before returning
			// #todo some kind of *unobtrusive* indicator/confirmation/option
			// #todo change color of textbox when message is properly signed

			if (message.trim().substring(0, 34) == ('-----BEGIN PGP SIGNED MESSAGE-----')) {
				return;
			}

			var privKeyObj = openpgp.key.readArmored(privkey).keys[0];

			//privateKey.decrypt(passPhrase);

			options = {
				data: message,                             // input as String (or Uint8Array)
				privateKeys: [privKeyObj]                  // for signing
			};

			openpgp.config.show_version = false;

			openpgp.config.show_comment = false;

			openpgp.sign(options).then(function(signed) {
				textbox.value = signed.data;
				composeForm.submit();
			});
		}
	} else {
		alert('No identity defined, cannot sign.');
	}

}


//var statusBox = document.getElementById('status');
//if (statusBox) {
//	statusBox.value = statusBox.value + '\nReady!';
//}

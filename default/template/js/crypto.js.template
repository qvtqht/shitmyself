// == begin crypto.js

// these are used to globally store the user's fingerprint and username
var myFingerprint = '';
var myUsername = '';

// performs logout by removing stored private key
function logOut(t) {
	if (t) {
		disarmSignoutButton(t);
	}
	logOut2();
}

function getPrivateKey() { // get private key from local storage
// returns null otherwise

	var privateKey = localStorage.getItem("privatekey");

	if (privateKey === null || privateKey.length === 0) {
		return null;
	} else {
		return privateKey;
	}
}

function buttonSignOut(t) { // sign out button is clicked. displays undo countdown or signs out completely, emptying trash 
	if (window.iii) { // iii is state of signout (1 if already clicked)
		logOut(t); //
	} else {
		window.privKeyTrash = getPrivateKey();

		removeStoredKeys();

		document.getElementById('locm').style.display='inline';
		t.style.backgroundColor='red';
		t.style.color='white';window.iii=1

		window.confct = 11;
		document.getElementById('btnUndo').value = 'Undo? ' + window.confct;

//		setTimeout(function(){
//			disarmSignoutButton(t);
//		}, 10000);

		var signinBox = document.getElementById('signin');
		signinBox.innerHTML = '<a href="/profile.html">Profile</a>';

		setTimeout(function(){
			signoutCounterDecrement();
		}, 1000);
	}
}

function undoSignout() {
	setPrivateKey(window.privKeyTrash);
	saveId();

	t = document.getElementById('rmid');
	disarmSignoutButton(t);

	var signinBox = document.getElementById('signin');
	signinBox.innerHTML = '<a href="/profile.html"><i>Profile</i></a>';

//	var logo = document.getElementById('logo');
//	if (logo) {
//		logo.href = '/author/' + fingerprint
//	} #todo

}

function signoutCounterDecrement() {
	var ct = window.confct;

	if (!window.privKeyTrash) {
		return;
	}

	if (ct) {
		if (isNaN(ct)) {
			// nothing
		} else {
			if (ct > 0) {
				window.confct = (ct - 1);
				bu = document.getElementById('btnUndo');
				bu.value = "Undo? " + ct;

				setTimeout(function(){
					signoutCounterDecrement();
				}, 1000);
			}
		}
	} else if (ct == 0) {
		var rmid = document.getElementById('rmid');
		buttonSignOut(rmid);
		logOut2();
		disarmSignoutButton(rmid);
		window.privKeyTrash = '';
		showHideForms();
	}
}

function disarmSignoutButton(t) {
	t.style.backgroundColor = '#c0c0c0';
	t.style.color = 'red';
	window.iii = 0;
	window.privKeyTrash = '';
	document.getElementById('locm').style.display='none';
}

var loading = document.getElementById('loading');
if (loading) {
	loading.style.display = 'none';
}


function getAvatar() { // retrieve previously built avatar from localstore (already in html form)
	var myAvatar = localStorage.getItem("avatar");
	if (myAvatar === null || myAvatar.length === 0) {
		return null;
	} else {
		return myAvatar;
	}
}

function logOut2() {
	removeStoredKeys();

	// clear the private key textbox if it can be found
	var textbox = document.getElementById("privatekey");
	if (textbox) {
		textbox.value = '';
	}

	// clear the public key textbox if it can be found
	textbox = document.getElementById("publickey");
	if (textbox) {
		textbox.value = '';
	}

	// remove displayed avatar at the top of the page
	var avatar = document.getElementById("myid");
	if (avatar) {
		avatar.innerHTML = '';
	}

	// remove the displayed avatar on the page
	avatar = document.getElementById("myAvatar");
	if (avatar) {
		avatar.innerHTML = '';
	}

	// show and hide the correct forms on the page, if applicable
	showHideForms();
}

function removeStoredKeys() { // remove login-related stored keys
	// remove the keys
	window.localStorage.removeItem("privatekey");
	window.localStorage.removeItem("publickey");
	window.localStorage.removeItem("fingerprint");
	window.localStorage.removeItem("avatar");
}

// begin html escape hack (credit stacko)
var escapeTA = document.createElement('textarea');
function escapeHTML(html) {
	escapeTA.textContent = html;
	return escapeTA.innerHTML;
}
function unescapeHTML(html) {
	escapeTA.innerHTML = html;
	return escapeTA.textContent;
}
// end html escape hack


// copy to clipboard i found, doesn't work on iphone
function fallbackCopyTextToClipboard(textareaId) {
  var textArea = document.getElementById(textareaId);
  textArea.focus();
  textArea.select();

  try {
	var successful = document.execCommand('copy');
	var msg = successful ? 'successful' : 'unsuccessful';
//	console.log('Fallback: Copying text command was ' + msg);
  } catch (err) {
//	console.error('Fallback: Oops, unable to copy', err);
  }
}

// copy to clipboard i found, doesn't work on iphone
function copyTextToClipboard(textareaId) {
  var textbox = document.getElementById(textareaId);
  var text = textbox.value;

  if (!navigator.clipboard) {
	fallbackCopyTextToClipboard(textareaId);
	return;
  }
  navigator.clipboard.writeText(text).then(function() {
//	console.log('Async: Copying to clipboard was successful!');
  }, function(err) {
//	console.error('Async: Could not copy text: ', err);
  });
}


// called from write.html#inspubkey
// used for sharing the stored public key automatically
function insertPubKey() {
	var comment = document.getElementById("comment");
	if (comment) {
		var pubkey = getPublicKey();

		if (pubkey) {
			comment.value = pubkey;
		}
	}
}

function getPublicKey() { // gets current user's cached public key from localstorage
	var publicKey = localStorage.getItem("publickey");
	if (publicKey === null || publicKey.length === 0) {
		return null;
	} else {
		return publicKey;
	}
}

// puts generated html avatar into localstorage
function setAvatar(avatar) {
	window.localStorage.setItem("avatar", avatar);
}

function hexToChar(string) { // converts hex characters to symbols for the now unused
// used by avatars that included different symbols instead of just two asterisks

	return string.replace(/0/gi,'~').replace(/1/gi,'@').replace(/2/gi,'#').replace(/3/gi,'$').replace(/4/gi,'%').replace(/5/gi,'^').replace(/6/gi,'&').replace(/7/gi,'*').replace(/8/gi,'+').replace(/9/gi,'=').replace(/a/gi,'>').replace(/b/gi,'<').replace(/c/gi,'|').replace(/d/gi,'}').replace(/e/gi,':').replace(/f/gi,'+');
}

function saveId() { // set the current private key and refresh the pubkey, fingerprint, and avatar too
// only if there's a private key textbox,
// not much validation currently #todo

	// look for textbox
	var textbox = document.getElementById("privatekey");

	if (textbox) {
		var privkey = textbox.value;

		// store it to localstorage
		setPrivateKey(privkey);

		if (!window.openpgp) {
			var script = document.createElement('script');
			script.src = '/openpgp.js';
			script.async = false; // This is required for synchronous execution
			document.head.appendChild(script);
		}

		var openpgp = window.openpgp;

		openpgp.config.show_version = false;
		openpgp.config.show_comment = false;

		// read it into pgp object
		var privKeyObj = openpgp.key.readArmored(privkey);;

		// get the public key out of it
		var pubKeyObj = privKeyObj.keys[0].toPublic();

		// store the armored version into localstorage
		var pubkey = pubKeyObj.armor();
		setPublicKey(pubkey);

		// get the fingerprint as uppercase hex and store it
		myFingerprint = pubKeyObj.primaryKey.keyid.toHex().toUpperCase();
		window.localStorage.setItem("fingerprint", myFingerprint);

		// get username out of key
		myUsername = pubKeyObj.users[0].userId.userid;

		var color1 = myFingerprint.substr(0, 6);
		var color2 = myFingerprint.substr(3, 6);
		var color3 = myFingerprint.substr(6, 6);
		var color4 = myFingerprint.substr(9, 6);

		var avatar = '';

//		var char1 = myFingerprint.substr(12, 1);
//		var char2 = myFingerprint.substr(13, 1);
//		var char3 = myFingerprint.substr(14, 1);

		//char1 = hexToChar(char1);
		//char2 = hexToChar(char2);
		//char3 = hexToChar(char3);
		//char4 = hexToChar(char4);

		var char1 = '*';
		var char2 = '*';

		avatar = ''

			+ '<span class=avatar style="background-color: #' + color1 + '">'
			+ '<span class=icon>'
			+ '<font color="#' + color2 + '">' + char1 + '</font>'
			+ '<font color="#' + color3 + '">' + char2 + '</font>'
			//+ '<font color="#' + color4 + '">' + char3 + '</font>'
			+ '</span>'
			+ '<span class=username>' + escapeHTML(myUsername) + '</span>'
			+ '</span>';

		setAvatar(avatar);

		// if there is a myid box, populate it appropriately
		var myidBox = document.getElementById('myid');
		if (myidBox) {
			var myAvatar = localStorage.getItem('avatar');
			var signinBox = document.getElementById('signin');

			if (myAvatar == null || myAvatar.length == 0) {
				if ( !document.getElementById("privatekey")) {
					signinBox.innerHTML = '<a href="/profile.html">Profile</a>';
				}
			} else {
				//signinBox.innerHTML = '';

				var myFp = localStorage.getItem('fingerprint');

				//myidBox.innerHTML = '<a href="/profile.html" class=avatar>' + myAvatar + '</a>';
				if (window.GetPrefs) {
					if (GetPrefs('display_username')) {
						myidBox.innerHTML = '<a href="/profile.html" class=avatar>' + myAvatar + '</a>';
						signinBox.innerHTML = '';
					} else {			
						signinBox.innerHTML = '<a href="/profile.html"><i>Profile</i></a>';
					}
				} else {
					signinBox.innerHTML = '<a href="/profile.html"><i>Profile</i></a>';
				}

				var myId2 = document.getElementById('myId2');
				if (myId2) {
//					myId2.innerHTML = getAvatar();
					myId2.innerHTML = '<a href="/author/' + myFp + '/">' + getAvatar() + '</a>'; //todo remove hardcoding of url
				}

				var myIdProfile = document.getElementById('myIdProfile');
				if (myIdProfile) {
					var profileUrl = '/author/' + myFingerprint + '/';

					if (UrlExists(profileUrl)) {
						myIdProfile.innerHTML = '<span class=beginner><a href="' + profileUrl + '">Go to your Profile page</a></span>';
						ShowAdvanced(1);
					} else {
						myIdProfile.innerHTML = '';
					}
				}

				var myCrea = document.getElementById('myCrea');
				if (myCrea) {
					myCrea.innerHTML = pubKeyObj.primaryKey.created.toString();
				}

				var myFinger = document.getElementById('myFP');
				if (myFinger) {
					myFinger.innerHTML = pubKeyObj.primaryKey.keyid.toHex().toUpperCase();
				}
			}

			showHideForms();
		}
	}
}

function setPrivateKey(privateKey) {
	window.localStorage.setItem("privatekey", privateKey);
}

function setPublicKey(publicKey) {
	window.localStorage.setItem("publickey", publicKey);
}

function getPublicKeyFromPrivateKey(privateKey) {
	var openpgp = window.openpgp;
	openpgp.initWorker({path:'openpgp.worker.js'});

	var privKeyObj = openpgp.key.readArmored(privateKey).keys[0];
}

function makePrivateKey(username, bits) {
	if (typeof(Storage) !== "undefined") {
		var privateKey = getPrivateKey();

		if (privateKey === null || privateKey.length === 0) {
			var privkey;
			var pubkey;

			var openpgp = window.openpgp;
			openpgp.initWorker({path:'openpgp.worker.js'});

			var options;
			if (bits == 512 || bits == 1024 || bits == 2048 || bits == 4096) {
				options = {
					userIds: [{ name: username }],
					numBits: bits,
					passphrase: ''
				};
			} else {
				options = {
					userIds: [{ name: username }],
					curve: bits,
					passphrase: ''
				};
			}

			var textbox = document.getElementById("privatekey");
			var genStatus = document.getElementById('genStatus');
			if (genStatus) {
				genStatus.innerHTML = 'Working...';
			}
			var cSb = document.getElementById('cSb');
			if (cSb) {
				cSb.disabled = 1;
			}

			openpgp.config.show_version = false;
			openpgp.config.show_comment = false;

			openpgp.generateKey(options).then(
				function(key) {
					setPrivateKey(key.privateKeyArmored);
					if (textbox) {
						textbox.value = key.privateKeyArmored;
					}
					if (genStatus) {
						genStatus.innerHTML = '';
					}
					if (cSb) {
						cSb.disabled = 0;
					}

					saveId();
					
					setPublicKey(key.publicKeyArmored);
					
//					sharePubKey();

//					var btnSharePubkey = document.getElementById('btnSharePub');
//					if (btnSharePubkey) {
//						btnSharePubkey.value = 'Share Public Key';
//						btnSharePubkey.disabled = false;
//					}
//
					//return frames["frame"].location.host;

					//window.open('/write.html#inspubkey', '_self');
				}
			);
		} else {
			// key already exists in storage
		}
	} else {
		// sorry, your browser does not support Web Storage...
	}
}

function sharePubKey3() {
	var pubKey = getPublicKey();
	
	var form = document.createElement('form');
	form.setAttribute("action", "/post.html");
	form.setAttribute("method", "get");	
	
	var txtComment = document.createElement('input');
	txtComment.setAttribute("type", "hidden");
	txtComment.setAttribute("value", pubKey);
	txtComment.setAttribute("name", "comment");
	
	form.appendChild(txtComment);
	document.getElementsByTagName('body')[0].appendChild(form);

	document.body.appendChild(form);
	
	form.submit();	
}

function sharePubKey2() {
	if (1 == 1) {
		return sharePubKey3();
	}
	
	var iframe = document.createElement("iframe");
	iframe.src = '/write.html#inspubkey';
	iframe.name = "inspubkey"
	iframe.style.display = 'none';
	document.body.appendChild(iframe);
}

function sharePubKey() {
	if (1 == 1) {
		return sharePubKey2();
	}
	
	window.open('/write.html#inspubkey', '_self');
}

function makeKeyFromInputs() {
	var privkey = getPrivateKey();

	if (privkey) {
		logOut2();
	}

	var user = document.getElementById('name').value;
	var bits = document.getElementById('bits').value;

	makePrivateKey(user, bits);
	
	return 0;
}

function insPubKey() {
	var pubkey = getPublicKey();

	if (pubkey) {
		var textbox = document.getElementById('comment');

		if (textbox) {
			if (pubkey) {
				textbox.value = pubkey;

				var writeIntro = document.getElementById('writeintro');
				if (writeIntro) {
					writeIntro.innerHTML = '<p class=writeinfo>Your public key is now being shared with the server. Please wait a moment...</p>';
				}

				var composeForm = document.getElementById('compose');
				if (composeForm) {
					composeForm.submit();
				}
			}
		}
	}
}

function insProfileTemplate() {
	var pubkey = getPublicKey();

	if (pubkey) {
		var textbox = document.getElementById('comment');

		if (textbox) {
			if (pubkey) {
				var writeIntro = document.getElementById('writeintro');
				if (writeIntro) {
					writeIntro.innerHTML = '<p class=writeinfo>This post will replace your current profile, if there is one set for you, as long as you take care to retain the header and footer.</p>';
				}

				textbox.value = '-----BEGIN PROFILE-----\n\n[This is just a template. All information is optional to provide. Edit and format as you like.]\n\nName: \n\nSelf-summary:\n\nFavorite Books:\n\nFavorite Quotes:\n\nContact Information:\n\n-----END PROFILE-----' ;
			}
		}
	}
}



function insVotes() {
	var vv = localStorage.getItem('vvvv');

	if (vv) {
		var textbox = document.getElementById('comment');

		if (textbox) {
			textbox.value = vv;
			localStorage.removeItem('vvvv');

			var writeIntro = document.getElementById('writeintro');
			if (writeIntro) {
				writeIntro.innerHTML = '<p class=writeinfo><b>Important: Press the Post button to register your votes.</b> You can also comment on a separate line from the command(s). Thank you for taking the time!</p>';
			}
		}
	}
}

function UrlExists(url) {
	var http = new XMLHttpRequest();
	http.open('HEAD', url, false);
	http.send();
	return (http.status==200);
}

function writeOnload2() {
	if (window.location.hash) {
		if (window.location.hash == '#inspubkey') {
			insPubKey();
		}
		if (window.location.hash == '#insvotes') {
			insVotes();
		}
		if (window.location.hash == '#profile') {
			insProfileTemplate();
		}
	}
	if (window.localStorage && window.localStorage.getItem('writesmall')) {
	    var writebox = document.getElementById('comment');
	    if (writebox) {
	        writebox.value = localStorage.getItem('writesmall');
	        localStorage.removeItem('writesmall');
	    }
	}
	if (document.getElementById) {
		var writeAdvL = document.getElementById('writeAdvL');
		if (writeAdvL) {
			writeAdvL.style.display = 'inline';
		}
		var userRadio = document.getElementById('userRadio');
//		alert(userRadio);
		if (userRadio) {
			if (window.getAvatar) {
				if (getAvatar()) {
					userRadio.innerHTML = '<label for=asign><input id=asign type=radio name=a value=sign> Sign as ' + getAvatar() + '</label>';
					//}
					var asign = document.getElementById('asign');
					if (asign) {
						asign.checked = 1;
						asign.checked = true;
					}
					//userRadio.innerHTML = '...';
				} else {
					userRadio.innerHTML = 'Sign in to post under identity.';
				}
			}
		}
	}
}

function writeSubmit() {
	if (document.forms['compose'].aanon.checked) {
		return true;
	} else if (document.forms['compose'].asign.checked) {
		signMessage();
		return false;
	} else {
//		console.log('neither anonymous nor signed option is checked. this should not happen under normal circumstances. submitting anyway!');
		return true;
		// this should not happen
	}
}

function signForm(formId) {
	var form = document.getElementById(formId);
	if (form) {
		var elements = form.elements;

		for (var i=0, element; element = elements[i++];) {
			//alert(element.type);
			//alert(element.name);
			//alert(element.value);
		}

		//	var elements = document.getElementById("my-form").elements;
		//
		//    for (var i = 0, element; element = elements[i++];) {
		//        if (element.type === "text" && element.value === "")
		//            console.log("it's an empty textfield")
		//    }

		//function getFormElelemets(formName){
		//  var elements = document.forms[formName].elements;
		//  for (i=0; i<elements.length; i++){
		//    some code...
		//  }
		//}

		//document.getElementById("someFormId").elements;


		//document.forms["form_name"].getElementsByTagName("input");


	} else {
		return null;
	}
}

//signForm('compose');
//
//function signMessage2(message) {
//	var privkey = getPrivateKey();
//
//	if (privkey) {
//		var textbox = document.getElementById('comment');
//		var composeForm = document.getElementById('compose');
//
//		textbox.style.color = '#00ff00';
//		textbox.style.backgroundColor = '#c0c000';
//
//		if (textbox && composeForm) {
//			var message = textbox.value;
//
//			var privKeyObj = openpgp.key.readArmored(privkey).keys[0];
//
//			options = {
//				data: message,                             // input as String (or Uint8Array)
//				privateKeys: [privKeyObj]                  // for signing
//			};
//
//			openpgp.config.show_version = false;
//
//			openpgp.config.show_comment = false;
//
//			openpgp.sign(options).then(function(signed) {
//				textbox.value = signed.data;
//				composeForm.submit();
//			});
//		}
//	} else {
//		alert('No identity defined, cannot sign.');
//	}
//
//}

function signMessage() {
	var privkey = getPrivateKey();

	if (privkey) {
		var textbox = document.getElementById('comment');
		var composeForm = document.getElementById('compose');

		if (textbox && composeForm) {
//			textbox.style.color = '#00ff00';
//			textbox.style.backgroundColor = '#c0c000';

			var message = textbox.value;
			
			// if the message already has the header,
			//    assume it's already signed and return
			// #todo make it also verify that it's signed before returning
			// #todo some kind of *unobtrusive* indicator/confirmation/option
			// #todo change color of textbox when message is properly signed

			if (message.trim().substring(0, 34) == ('-----BEGIN PGP SIGNED MESSAGE-----')) {
				return;
			}
			
			var replyTo = document.getElementById('replyto');

			if (replyTo) {
				var replyToId = replyTo.value;

				if (replyToId) {
					if (message.indexOf('>>' + replyToId) > -1) {
					} else {
						message = '>>' + replyToId + '\n\n' + message;
					}
				}
			}
//			
			var privKeyObj = openpgp.key.readArmored(privkey).keys[0];
//
//			privateKey.decrypt('hello');
//
//			var privKeyObj = (await openpgp.key.readArmored(privkey)).keys[0];
//			await privKeyObj.decrypt(passphrase);
//			

			options = {
				data: message,                             // input as String (or Uint8Array)
				privateKeys: [privKeyObj]                  // for signing
			};

			openpgp.config.show_version = false;

			openpgp.config.show_comment = false;

			openpgp.sign(options).then(function(signed) {
				textbox.value = signed.data;
				composeForm.submit();
			});
		}
	} else {
		alert('No identity defined, cannot sign.');
	}

}


//var statusBox = document.getElementById('status');
//if (statusBox) {
//	statusBox.value = statusBox.value + '\nReady!';
//}

// == end crypto.js
<?php

function WriteLog($text) { // writes to debug log if enabled
	static $logText;

	if (!$logText) {
		$logText = '';
	}

	if (!$text) {
		return $logText;
	}

    //#todo sanity check for $text being a string
	$logText .= '<tt class=advanced>' . time() . ':' . htmlspecialchars($text) . "<br></tt>\n";
}

//
//function GetAdminKey() { // Returns admin's public key, 0 if there is none
//	static $adminsKey = 0;
//
//	if ($adminsKey) {
//		return $adminsKey;
//	}
//
//	$pwd = getcwd();
//
//	WriteLog('$pwd = ' . $pwd);
//
//	$scriptDir = substr($pwd, 0, strlen($pwd) - 5); // trim html/
//
//	if (file_exists("$scriptDir/admin.key")) {
//
//		$adminsInfo = GpgParse("$scriptDir/admin.key");
//
//		if ($adminsInfo['isSigned']) {
//			if ($adminsInfo['key']) {
//				$adminsKey = $adminsInfo['key'];
//
//				return $adminsKey;
//			} else {
//				return 0;
//			}
//		} else {
//			return 0;
//		}
//	} else {
//		return 0;
//	}
//
//	return 0;
//}


function GetMyVersion() { // returns current git commit id
	static $myVersion;

	if ($myVersion) {
		return $myVersion;
	}

	$myVersion = GetConfig('admin/my_version');

	if (!$myVersion) {
		$myVersion = `git rev-parse HEAD`;
	}

	$myVersion = trim($myVersion);

	return $myVersion;
}

function index($string, $needle) { // emulates perl's index(), returning -1 instead of false
	$strpos = strpos($string, $needle);
	if ($strpos === false) {
		return -1;
	} else {
		return $strpos;
	}
}

function length($string) { // emulates perl's length()
	return strlen($string);
}

function GpgParsePubkey($filePath) {
    return array();
}

function GpgParseSignedMessage($filePath) {
	$gpgCommand = 'gpg2'; // todo add gpg1 support
	$gpgStderr = ''; // string appended to commands to capture stderr output if configured

	if (GetConfig('admin/gpg/capture_stderr_output')) {
	    // capture stderr output
    	$gpgStderr = '2>&1';
    } else {
    	if (GetConfig('admin/php/debug')) {
    	    // if debug is on, let it go to stderr
    		$gpgStderr = '';
    	} else {
    	    // if not in debug mode, send it to /dev/null
    		$gpgStderr = ' 2>/dev/null';
    	}
    }

////////////////

    WriteLog("GpgParseSignedMessage($filePath)");

    $gpgResult = `$gpgCommand --verify --status-fd 1 "$filePath" $gpgStderr`;
    WriteLog('$gpgResult = ' . "$gpgCommand --verify --status-fd 1 \"$filePath\" $gpgStderr");
    WriteLog('$gpgResult: ' . $gpgResult);

    $key_id_prefix = '';
    $key_id_suffix = '';

    $verifyError = 0;

    if (index($gpgResult, "[GNUPG:] GOODSIG ") >= 0) {
        $key_id_prefix = "[GNUPG:] GOODSIG ";
        $key_id_suffix = " ";
    }

    $keyExpired = 0;
    if (index($gpgResult, "[GNUPG:] EXPKEYSIG ") >= 0) {
        $key_id_prefix = "[GNUPG:] EXPKEYSIG ";
        $key_id_suffix = " ";

        $keyExpired = 1;
    }

    WriteLog('$key_id_prefix = ' . $key_id_prefix);
    WriteLog('$key_id_suffix = ' . $key_id_suffix);

    if ($key_id_prefix && (!$verifyError || GetConfig('admin/allow_broken_signatures'))) {
        // Extract the key fingerprint from GPG's output.
        $gpg_key = substr($gpgResult, index($gpgResult, $key_id_prefix) + length($key_id_prefix));
        $gpg_key = substr($gpg_key, 0, index($gpg_key, $key_id_suffix));

        WriteLog("$gpgCommand --decrypt \"$filePath\" $gpgStderr");

        $message = `$gpgCommand --decrypt "$filePath" $gpgStderr`;

        $isSigned = 1;
    }

    $txt = file_get_contents($filePath);
    $fileHash = sha1_file($filePath);

    $returnValues['isSigned'] = $isSigned;
    $returnValues['text'] = $txt;
    $returnValues['message'] = $message;
    $returnValues['key'] = $gpg_key;
    $returnValues['keyExpired'] = $keyExpired;
    $returnValues['gitHash'] = $fileHash;
    $returnValues['verifyError'] = $verifyError;

    return $returnValues;
}

function file_force_contents($dir, $contents){
    WriteLog("file_force_contents($dir, $contents)");

    $parts = explode('/', $dir);
    $file = array_pop($parts);
    $dir = '';

    foreach($parts as $part) {
        if (!is_dir($dir .= "/$part")) {
            mkdir($dir);
        }
    }

    return file_put_contents("$dir/$file", $contents);
}


function GpgParse($filePath) {
	$gpgCommand = 'gpg2'; // todo add gpg1 support
	$gpgStderr = ''; // string appended to commands to capture stderr output if configured

	if (GetConfig('admin/gpg/capture_stderr_output')) {
	    // capture stderr output
    	$gpgStderr = '2>&1';
    } else {
    	if (GetConfig('admin/php/debug')) {
    	    // if debug is on, let it go to stderr
    		$gpgStderr = '';
    	} else {
    	    // if not in debug mode, send it to /dev/null
    		$gpgStderr = ' 2>/dev/null';
    	}
    }

	WriteLog('GpgParse(' . $filePath . ')');

	if (file_exists($filePath)) {
	// file should exist
		WriteLog('GpgParse: File exists');

		$txt = file_get_contents($filePath); // contains text file contents

		$fileHash = sha1_file($filePath);

        $cachePath = "./cache/" . GetMyVersion() . "/gpg/php/$fileHash.cache";
        // this is where we will cache results for later use
        // php's cache is separate from perl's because it's in a different format

        if (file_exists($cachePath)) {
            // if file at $cachePath exists, means we've already done this before, just return cached data
            WriteLog('GpgParse: ' . $cachePath . ' exists');
            $returnValues = unserialize(file_get_contents($cachePath));
        } else {
            // no cache, gotta do the dirty work...

            $message = $txt; // will contain message output for user including results of parsing in place of tokens

            if ($fileHash) {
            // sanity check, but if there is no $fileHash, something is wrong and we shouldn't keep going
                WriteLog('GpgParse: $fileHash = ' . $fileHash);

                $returnValues = array(); // will store return values from function

                // this is where it gets ugly...

                WriteLog('GpgParse: beginning search...');

                // what to look for to figure out message type
                $gpgMessageHeader = "-----BEGIN PGP SIGNED MESSAGE-----"; // Signed messages header
                $gpgPubkeyHeader = "-----BEGIN PGP PUBLIC KEY BLOCK-----"; // Public key header
                $gpgEncryptedHeader = "-----BEGIN PGP MESSAGE-----"; // Encrypted message header

                $trimmedTxt = trim($txt);

                if (strpos($txt, $gpgMessageHeader) !== false) {
                    $returnValues = GpgParseSignedMessage($filePath);

                    file_force_contents($cachePath, serialize($returnValues));

                    return $returnValues;
                }

                if (strpos($txt, $gpgPubkeyHeader) !== false) {
                    $returnValues = GpgParsePubkey($filePath);

                    file_put_contents($cachePath, serialize($returnValues));

                    return $returnValues;
                }
            }
		}
	} else {
		WriteLog('GpgParse(' . $filePath . ') -- file does not exist');
		return '';
	}
}

function DoUpdate() {
	$pwd = getcwd();

	WriteLog('$pwd = ' . $pwd);

	$scriptDir = substr($pwd, 0, strlen($pwd) - 5); // trim html/

	WriteLog('$scriptDir = ' . $scriptDir);

	if (file_exists($scriptDir . '/update.pl')) {
		WriteLog('update.pl found, calling update.pl --all');
		WriteLog('cd "' . $scriptDir . '" ; perl ./update.pl --all');

		WriteLog(`cd "$scriptDir" ; perl ./update.pl --all`);

		WriteLog('cd "' . $pwd . '"');

		WriteLog(`cd "$pwd"`);
	}

//		if (!file_exists($scriptDir . 'cron.lock')) {
//			WriteLog('cron.lock no exist, trying index.pl');
//
//			if (file_exists($scriptDir . '/index.pl')) {
//				WriteLog('index.pl found, calling');
//
//				WriteLog('cd "' . $scriptDir . '" ; perl ./index.pl "' . $filePath . '"');
//
////				WriteLog(`cd "$scriptDir" ; perl ./index.pl "$filePath"`);
//			}
//
//			if (file_exists($scriptDir . '/touched.pl')) {
//				WriteLog('touched.pl found, calling');
//
//				WriteLog('cd "' . $scriptDir . '" ; perl ./touched.pl');
//
////				WriteLog(`cd "$scriptDir" ; perl ./touched.pl`);
//			}

//		} else {
//
//		}

}

function GetConfig($configKey) { // get value for config value $configKey
// config is stored in config/
// if not found in config/ it looks in default/
// if it is in default/, it is copied to config/
	//$configDir = '/home/ily/hike/config/'; // config is stored here
	//$defaultDir = '/home/ily/hike/default/'; // defaults are stored here

	$configDir = '../config/'; // config is stored here
	$defaultDir = '../default/'; // defaults are stored here

	WriteLog('GetConfig('.$configKey.'); $configDir = "' . $configDir . '", $defaultDir = "' . $defaultDir . '", pwd = "' . getcwd() . '"');

	WriteLog('Checking in ' . $configDir . $configKey );

	if (file_exists($configDir . $configKey)) {
		WriteLog('found in config/');

		$configValue = file_get_contents($configDir . $configKey);
	} elseif (file_exists($defaultDir . $configKey)) {
		WriteLog('found in default/');

		copy ($defaultDir . $configKey, $configDir . $configKey); // copy to config/
		$configValue = file_get_contents($configDir . $configKey);
	} else {
		// otherwise return empty string
		WriteLog('returning empty string');
		$configValue = '';
	}

	$configValue = trim($configValue); // remove trailing \n and any other whitespace

	WriteLog('GetConfig("' . $configKey . '") = "' . $configValue . '")');
	// notify log of what we found

	return $configValue;
}

function GetTemplate($templateKey) { // get template from config tree
// looks in theme directory first, so config/theme/ > default/theme/ > config/ > default/
    $themeName = GetConfig('html/theme');
    $themePath = 'theme/' . $themeName . '/template/' . $templateKey;

    if (GetConfig($themePath)) {
        return GetConfig($themePath);
    } else {
	    return GetConfig('template/' . $templateKey);
    }
}




function GetFile($file) {
	return file_get_contents($file);
}

function PutFile($file, $content) {
	return file_put_contents($file, $content);
//	return file_force_contents($file, $content);
}

function GetCache($cacheName) { // get cache by cache key
	// comes from cache/ directory, under current git commit
	// this keeps cache version-specific

	static $myVersion;
	if (!$myVersion) {
		$myVersion = GetMyVersion();
	}

	// cache name prefixed by current version
	$cacheName = '../cache/' . $myVersion . '/' . $cacheName;

	if (file_exists($cacheName)) {
		// return contents of file at that path
		return GetFile($cacheName);
	} else {
		return;
	}
}

function PutCache($cacheName, $content) { // stores value in cache; $cacheName, $content
//#todo sanity checks and error handling
	static $myVersion;
	if (!$myVersion) {
		$myVersion = GetMyVersion();
	}

	$cacheName = '../cache/' . $myVersion . '/' . $cacheName;

	return PutFile($cacheName, $content);
}

function UnlinkCache($cacheName) { // removes cache by unlinking file it's stored in
	static $myVersion;
	if (!$myVersion) {
		$myVersion = GetMyVersion();
	}

	$cacheName = '../cache/' . $myVersion . '/' . $cacheName;

	if (file_exists($cacheName)) {
		unlink($cacheName);
	}
}

function CacheExists($cacheName) { // Check whether specified cache entry exists, return 1 (exists) or 0 (not)
	static $myVersion;
	if (!$myVersion) {
		$myVersion = GetMyVersion();
	}

	$cacheName = '..cache/' . $myVersion . '/' . $cacheName;

	if (file_exists($cacheName)) {
		return 1;
	} else {
		return 0;
	}
}


function StoreServerResponse ($message) { // adds server message and returns message id
// stores server message in cache/sm[message_id]
// returns message id which can be passed to next page load via ?message=

    // #todo static $messages array
    // #todo push message to array

	$message = trim($message);

    if ($message == '') {
    	return;
    }

    $messageId = md5($message . time()); // #todo better?
    $messageId = substr($messageId, 0, 8);

	PutCache('sm' . $messageId, $message);

	return $messageId;
}

function RetrieveServerResponse ($messageId) { // retrieves response message for display by client and deletes it
	WriteLog("RetrieveServerResponse($messageId)");

	$message = GetCache('sm' . $messageId);

	if ($message) {
		WriteLog("RetrieveServerResponse: Message found, deleting");

		UnlinkCache('sm' . $messageId);
	}

	return $message;
}

function GetHtmlFilename($hash) {
	// path for new html file
	$fileHtmlPath =
		substr($hash, 0, 2) .
		'/' .
		substr($hash, 2, 2) .
		'/' .
		substr($hash, 0, 8) .
		'.html'
	;

	return $fileHtmlPath;
}

function GetWindowTemplate($windowTitle, $windowMenubarContent, $columnHeadings, $windowBody, $windowStatus) {
// returns template for html-table-based-"window"
	$contentColumnCount = 0;

	$windowTemplate = GetTemplate('window/standard.template');

	if ($windowTitle) {
		$windowTitlebar = GetTemplate('window/titlebar.template');
		$windowTitlebar = str_replace('$windowTitle', $windowTitle, $windowTitlebar);

		$windowTemplate =~ str_replace('$windowTitlebar', $windowTitlebar, $windowTemplate);
	} else {
		$windowTemplate =~ str_replace('$windowTitlebar', '', $windowTemplate);
	}

	if ($windowMenubarContent) {
		$windowMenubar = GetTemplate('window/menubar.template');
		$windowMenubar = str_replace('$windowMenubarContent', $windowMenubarContent, $windowMenubar);

		$windowTemplate = str_replace('$windowMenubar', $windowMenubar, $windowTemplate);
	} else {
		$windowTemplate = str_replace('$windowMenubar', '', $windowTemplate);
		//#todo currently results in an empty menubar
	}

	if ($columnHeadings) {
		$windowHeaderTemplate = GetTemplate('window/header_wrapper.template');
		$windowHeaderColumns = '';
		$columnsArray = explode(',', $columnHeadings);

		$printedColumnsCount = 0;
		foreach ($columnsArray as $columnCaption) {
			$printedColumnsCount++;

			$columnHeaderTemplate = GetTemplate('window/header_column.template');
			if ($printedColumnsCount >= count($columnsArray)) {
				$columnCaption .= '<br>'; //# for no-table browsers
			}

			$columnHeaderTemplate = str_replace('$headerCaption', $columnCaption, $columnHeaderTemplate);
			$windowHeaderColumns .= $columnHeaderTemplate;
		}

		$windowHeaderTemplate = str_replace('$windowHeadings', $windowHeaderColumns, $windowHeaderTemplate);
		$windowTemplate = str_replace('$windowHeader', $windowHeaderTemplate, $windowTemplate);

		$contentColumnCount = count($columnsArray);
	} else {
		$windowTemplate = str_replace('$windowHeader', '', $windowTemplate);
		$contentColumnCount = 0;
	}

	if ($windowBody) {
		if (index(strtolower($windowBody), '<tr') == -1) {
			// put content into a table row and cell if missing
			$windowBody = '<tr class=content><td>' . $windowBody . '</td></tr>';
		}

		$windowTemplate = str_replace('$windowBody', $windowBody, $windowTemplate);
	} else {
		$windowTemplate = str_replace('$windowBody', '', $windowTemplate);
	}

	if ($windowBody) {
		$windowTemplate = str_replace('$windowStatus', $windowStatus, $windowTemplate);
	} else {
		$windowTemplate = str_replace('$windowStatus', '', $windowTemplate);
	}

	if ($contentColumnCount) {
		$windowTemplate = str_replace('$contentColumnCount', $contentColumnCount, $windowTemplate);
	} else {
		$windowTemplate = str_replace('$contentColumnCount', '', $windowTemplate);
	}

	return $windowTemplate;
}

function GetThemeAttribute($attributeName) { // returns theme color from config/theme/
	$themeName = GetConfig('html/theme');

	$attributePath = 'theme/' . $themeName . '/' . $attributeName;
	//#todo sanity checks

	$attributeValue = GetConfig($attributePath);
	$attributeValue = trim($attributeValue);

	WriteLog('GetThemeAttribute: $attributeName: ' . $attributeName . '; $attributePath: ' . $attributePath . '; $attributeValue: ' . $attributeValue);

	return $attributeValue;
}

function GetThemeColor($colorName) { // returns theme color based on html/theme
	$colorName = 'color/' . $colorName;

	$color = GetThemeAttribute($colorName);

	if (!$color) {
		$color = 'red';
		WriteLog("GetThemeColor: WARNING: Value for $colorName not found");
	}

	if (preg_match('/^[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]$/', $color)) {
		WriteLog('GetThemeColor: Color found missing its # prefix: ' . $color);

		$color = '#' . $color;

		WriteLog('GetThemeColor: Prefix added: ' . $color);
	} else {
		WriteLog('GetThemeColor: Found nice color: ' . $color);
	}

	WriteLog('GetThemeColor: Returning for ' . $colorName . ': ' . $color);

	return $color;
}

function GetTime() {
	return time();
}

function GetClockFormattedTime() { // returns current time in appropriate format from config
//formats supported: union, epoch (default)

	$clockFormat = GetConfig('html/clock_format');

	if ($clockFormat == 'union') {
		$time = GetTime();

		// #todo make it perl-equivalent with locatime($time)
		$hours = strftime('%H', $time);
		$minutes = strftime('%M', $time);
		$seconds = strftime('%S', $time);

		$milliseconds = '000';
		$hoursR = 23 - $hours;
		if ($hoursR < 10) {
			$hoursR = '0' . $hoursR;
		}

		$minutesR = 59 - $minutes;
		if ($minutesR < 10) {
			$minutesR = '0' . $minutesR;
		}

		$secondsR = 59 - $seconds;
		if ($secondsR < 10) {
			$secondsR = '0' . $secondsR;
		}

		#
		# if (milliseconds < 10) {
		# 	milliseconds = '00' + '' + milliseconds;
		# } else if (milliseconds < 100) {
		# 	milliseconds = '0' + '' + milliseconds;
		# }
		#

		$clockFormattedTime = $hours . $minutes . $seconds . $milliseconds . $secondsR . $minutesR . $hoursR;

		return $clockFormattedTime;
	}

	return GetTime();
}


function setcookie2 ($key, $value) { //wrapper for setcookie() which sets cookie with parameters
	if (0) {
		WriteLog('setcookie2(' . $key . ',' . $value . ')');
		setcookie($key, $value);
	} else {
//    		$date = new Datetime('+2 years');
//    		$cookieDate = $date->format(DateTime::COOKIE);
//    		Header('Set-Cookie: ' . $key . '=' . $value . '; expires=' . $cookieDate . '; path=/');

		setcookie($key, $value, time()+86400, '/'); //#todo ie3 compat
	}
}

function unsetcookie2($key) { // wrapper for setcookie() to remove a cookie
	if (0) {
		WriteLog('unsetcookie2(' . $key . ')');
		setcookie($key);
	} else {
		setcookie($key, '', time()-86400, '/');
	}
}
